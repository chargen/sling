package sling

import (
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// HTTPRequestable implementations create a request to the given base url
// as well as a HTTPResponder method object which will receive the HTTP
// response generated by the execution of the returned request.
//
// Errors may be returned for any misfiguration of the requestable.
type HTTPRequestable interface {
	HTTPRequest(*url.URL) (*http.Request, HTTPResponder, error)
}

// HTTPResponder implementations process a HTTP response according
// to their prior configuration.
//
// Errors may be returned for malformed responses or those which
// do not match the responder's configuration or are configured
// to return an error.
type HTTPResponder interface {
	OnHTTPResponse(*http.Response) error
}

// HTTP implementations perform a request/response cycle using the provided
// HTTPRequestable.
// It is not required that any portion of request processing be run on the
// calling goroutine.
type HTTP interface {
	// Do runs the given HTTPRequestable, and returns any errors produced.
	Do(HTTPRequestable) error
}

type httpClient struct {
	netHTTPClient
	*url.URL
}

func newHTTP(baseURL string, client netHTTPClient) (HTTP, error) {
	parsed, err := url.Parse(strings.TrimRight(baseURL, "/") + "/")
	if err != nil {
		return nil, err
	}

	if parsed.Scheme != "http" && parsed.Scheme != "https" {
		return nil, errors.New("Only http and https are supported")
	}

	return &httpClient{
		netHTTPClient: client,
		URL:           parsed,
	}, nil
}

func (client *httpClient) Do(requestable HTTPRequestable) error {
	request, responder, err := requestable.HTTPRequest(client.URL)
	if err != nil {
		return err
	}
	request.Header.Set("Connection", "keep-alive")

	response, err := client.netHTTPClient.Do(request)
	defer closeResponse(response)
	if err != nil {
		return err
	}
	return responder.OnHTTPResponse(response)
}

func closeResponse(response *http.Response) {
	if response != nil && response.Body != nil {
		// NOTE(lcooper): we need to ensure that the response body sees an EOF,
		// otherwise our connection will get closed down. But the JSON decoder
		// stops reading once the outer object finishes, and CouchDB ends its
		// responses with "\n", so we need to make sure that this is read.
		// TODO(lcooper): test this, it's sort of important.
		ioutil.ReadAll(response.Body)
		response.Body.Close()
	}
}
